<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://code.jquery.com/pep/0.4.2/pep.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/libktx.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
      
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
   

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #iddivp{


                position:absolute;
                top: 0%;
                left: 0%;
                width: 130px;
                height: 100px;
                background-color: rgb(90, 86, 86);
                font-size: 22px;
                color: rgb(168, 168, 168);

                display: flex;
	flex-direction: column;
	flex-wrap: nowrap;
	justify-content: flex-start;
	align-items: stretch;
	align-content: stretch;
            }
        </style>
    </head>
<body>
    <div id="iddivp">

<p id="idp1">p1111111</p>
<p id="idp2">pppppp2</p>

    </div>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true }); };
        var createScene = function () {
            var scene = new BABYLON.Scene(engine);
        
            // Lights
            var light0 = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(-2, -5, 2), scene);
            var light1 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(2, -5, -2), scene);
        
            // Need a free camera for collisions
            var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, -8, -20), scene);
            camera.attachControl(canvas, true);
        
            //Ground
            var ground = BABYLON.Mesh.CreatePlane("ground", 100, scene);
            ground.material = new BABYLON.StandardMaterial("groundMat", scene);
            ground.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
            ground.material.backFaceCulling = false;
            ground.position = new BABYLON.Vector3(5, -10, -15);
            ground.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);
        
            //Simple crate
            var box = BABYLON.Mesh.CreateBox("crate", 2, scene);
            box.material = new BABYLON.StandardMaterial("Mat", scene);
            box.material.diffuseTexture = new BABYLON.Texture("textures/crate.png", scene);
            box.material.diffuseTexture.hasAlpha = true;
            box.position = new BABYLON.Vector3(0, -8, 0);
        
            //Set gravity for the scene (G force like, on Y-axis)
            scene.gravity = new BABYLON.Vector3(0, -0.9, 0);
        
            // Enable Collisions
            scene.collisionsEnabled = true;
        
            //Then apply collisions and gravity to the active camera
            camera.checkCollisions = true;
            camera.applyGravity = true;
        
            //Set the ellipsoid around the camera (e.g. your player's size)
            camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);
        
            //finally, say which mesh will be collisionable
            ground.checkCollisions = true;
            box.checkCollisions = true;
        
          let adt = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            let xAddPos = 0;
            let yAddPos = 0;
            let xAddRot = 0;
            let yAddRot = 0;
            let sideJoystickOffset = 150;
            let bottomJoystickOffset = -50;
            let translateTransform;    
        
        
          let leftThumbContainer = makeThumbArea("leftThumb", 2, "blue", null);
              leftThumbContainer.height = "200px";
              leftThumbContainer.width = "200px";
              leftThumbContainer.isPointerBlocker = true;
              leftThumbContainer.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
              leftThumbContainer.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
              leftThumbContainer.alpha = 0.4;
              leftThumbContainer.left = sideJoystickOffset;
              leftThumbContainer.top = bottomJoystickOffset;
        
          let leftInnerThumbContainer = makeThumbArea("leftInnterThumb", 4, "blue", null);
              leftInnerThumbContainer.height = "80px";
              leftInnerThumbContainer.width = "80px";
              leftInnerThumbContainer.isPointerBlocker = true;
              leftInnerThumbContainer.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
              leftInnerThumbContainer.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        
        
          let leftPuck = makeThumbArea("leftPuck",0, "blue", "blue");
                  leftPuck.height = "60px";
                  leftPuck.width = "60px";
                  leftPuck.isPointerBlocker = true;
                  leftPuck.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
                  leftPuck.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        
        
              leftThumbContainer.onPointerDownObservable.add(function(coordinates) {
                  leftPuck.isVisible = true;
                  leftPuck.floatLeft = coordinates.x-(leftThumbContainer._currentMeasure.width*.5)-sideJoystickOffset;
                  leftPuck.left = leftPuck.floatLeft;
                  leftPuck.floatTop = adt._canvas.height - coordinates.y-(leftThumbContainer._currentMeasure.height*.5)+bottomJoystickOffset;
                  leftPuck.top = leftPuck.floatTop*-1;
                  leftPuck.isDown = true;
                  leftThumbContainer.alpha = 0.9;
              });
        
              leftThumbContainer.onPointerUpObservable.add(function(coordinates) {
                  xAddPos = 0;
                  yAddPos = 0;
                  leftPuck.isDown = false;
                  leftPuck.isVisible = false;
                  leftThumbContainer.alpha = 0.4;
              });
        
        
              leftThumbContainer.onPointerMoveObservable.add(function(coordinates) {
                  if (leftPuck.isDown) {
                      xAddPos = coordinates.x-(leftThumbContainer._currentMeasure.width*.5)-sideJoystickOffset;
                      yAddPos = adt._canvas.height - coordinates.y-(leftThumbContainer._currentMeasure.height*.5)+bottomJoystickOffset;
                      leftPuck.floatLeft = xAddPos;
                      leftPuck.floatTop = yAddPos*-1;
                      leftPuck.left = leftPuck.floatLeft;
                      leftPuck.top = leftPuck.floatTop;
                      }
              });
        
           adt.addControl(leftThumbContainer);
           leftThumbContainer.addControl(leftInnerThumbContainer);
           leftThumbContainer.addControl(leftPuck);
           leftPuck.isVisible = false;
        
           let rightThumbContainer = makeThumbArea("rightThumb", 2, "red", null);
               rightThumbContainer.height = "200px";
               rightThumbContainer.width = "200px";
               rightThumbContainer.isPointerBlocker = true;
               rightThumbContainer.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
               rightThumbContainer.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
               rightThumbContainer.alpha = 0.4;
               rightThumbContainer.left = -sideJoystickOffset;
               rightThumbContainer.top = bottomJoystickOffset;
        
           let rightInnerThumbContainer = makeThumbArea("rightInnterThumb", 4, "red", null);
               rightInnerThumbContainer.height = "80px";
               rightInnerThumbContainer.width = "80px";
               rightInnerThumbContainer.isPointerBlocker = true;
               rightInnerThumbContainer.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
               rightInnerThumbContainer.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        
        
           let rightPuck = makeThumbArea("rightPuck",0, "red", "red");
                   rightPuck.height = "60px";
                   rightPuck.width = "60px";
                   rightPuck.isPointerBlocker = true;
                   rightPuck.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
                   rightPuck.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        
        
               rightThumbContainer.onPointerDownObservable.add(function(coordinates) {
                   rightPuck.isVisible = true;
                   rightPuck.floatLeft = adt._canvas.width - coordinates.x-(rightThumbContainer._currentMeasure.width*.5)-sideJoystickOffset;
                   rightPuck.left = rightPuck.floatLeft*-1;
                   rightPuck.floatTop = adt._canvas.height - coordinates.y-(rightThumbContainer._currentMeasure.height*.5)+bottomJoystickOffset;
                   rightPuck.top = rightPuck.floatTop*-1;
                   rightPuck.isDown = true;
                   rightThumbContainer.alpha = 0.9;
               });
        
               rightThumbContainer.onPointerUpObservable.add(function(coordinates) {
                   xAddRot = 0;
                   yAddRot = 0;
                   rightPuck.isDown = false;
                   rightPuck.isVisible = false;
                   rightThumbContainer.alpha = 0.4;
               });
        
        
               rightThumbContainer.onPointerMoveObservable.add(function(coordinates) {
                   if (rightPuck.isDown) {
                       xAddRot = adt._canvas.width - coordinates.x-(rightThumbContainer._currentMeasure.width*.5)-sideJoystickOffset;
                       yAddRot = adt._canvas.height - coordinates.y-(rightThumbContainer._currentMeasure.height*.5)+bottomJoystickOffset;
                       rightPuck.floatLeft = xAddRot*-1;
                       rightPuck.floatTop = yAddRot*-1;
                       rightPuck.left = rightPuck.floatLeft;
                       rightPuck.top = rightPuck.floatTop;
                       }
               });
        
            //leftThumbContainer.left = 50;
            adt.addControl(rightThumbContainer);
            rightThumbContainer.addControl(rightInnerThumbContainer);
            rightThumbContainer.addControl(rightPuck);
            rightPuck.isVisible = false;
        
              camera.attachControl(canvas, true);
        
   
        
        function makeThumbArea(name, thickness, color, background, curves){
           let rect = new BABYLON.GUI.Ellipse();
               rect.name = name;
               rect.thickness = thickness;
               rect.color = color;
               rect.background = background;
               rect.paddingLeft = "0px";
               rect.paddingRight = "0px";
               rect.paddingTop = "0px";
               rect.paddingBottom = "0px";
        
        
        
        
           return rect;
        }

       /* BABYLON.SceneLoader.ImportMesh("", "./", "cb.glb", scene, function (newMeshes, particleSystems, skeletons,animp) {
      
      console.log(newMeshes);
        
                // ROBOT
   
        
             
            });	
*/
scene.registerBeforeRender(function(){
                      translateTransform = BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(xAddPos/3000, 0, yAddPos/3000), BABYLON.Matrix.RotationY(camera.rotation.y));
                      camera.cameraDirection.addInPlace(translateTransform);
                      camera.cameraRotation.y += xAddRot/15000*-1;
                      camera.cameraRotation.x += yAddRot/15000*-1;
           //objcb.rotation.x=objcb.rotation.x+ifa;

          // objcb.rotate(BABYLON.Axis.Z, 0.025, BABYLON.Space.WORLD);
     // ifa=-2+ifa*1;
    document.getElementById("idp1").innerHTML="ifa";
                }); 
            BABYLON.SceneLoader.ImportMesh("", "./", "escoepta.glb", scene, function (newMeshes,pt,anmia) {
        // Set the target of the camera to the first imported mesh
     //   camera.target = newMeshes[0];
    
       // newMeshes[0].position.z=-4;
  objcb=newMeshes[0];
     objcb.position.y=-7;
  document.getElementById("idp1").innerHTML=objcb.position;

anmia[0].play();


    });







            return scene;
        }

        var ifa=0;


var engine;
try {
    engine = createDefaultEngine();
} catch(e) {
    console.log("the available createEngine function failed. Creating the default engine instead");
    engine = createDefaultEngine();
}
        if (!engine) throw 'engine should not be null.';
        scene = createScene();;
        sceneToRender = scene

        engine.runRenderLoop(function () {
            if (sceneToRender) {
                sceneToRender.render();
            }
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });


var minew;

var idpa=0;
var objcb;
        
    </script>
</body>
</html>
